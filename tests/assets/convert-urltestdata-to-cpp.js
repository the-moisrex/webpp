const fs = require('fs');
const path = require('path');
const readline = require('readline');

function convertToCamelCase(sentence) {
  // Remove invalid characters and split the sentence into words
  const words =
      sentence.replace(/[^a-zA-Z0-9 ]/g, ' ').replace(/\s+/g, ' ').split(' ');

  // Convert words to CamelCase
  const camelCaseWords = words.map((word) => {
    // Convert subsequent words to uppercase first letter
    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
  });

  // Join the CamelCase words and return the result
  return camelCaseWords.join('');
}

function escapeForCppString(str) {
  return str
      .replace(/\\/g, '\\\\') // Escape backslashes
      .replace(/"/g, '\\"')   // Escape double quotes
      .replace(/\n/g, '\\n')  // Escape newlines
      .replace(/\r/g, '\\r')  // Escape carriage returns
      .replace(/\t/g, '\\t')  // Escape tabs
      .replace(/\x00/, '\\0')
      // Replace unpaired UTF-8 bidirectional control characters with a suitable
      // replacement
      .replace(/[\u202A-\u202E\u200E\u200F]/g, ch => {
        return '\\u' +
               ch.charCodeAt(0).toString(16).padStart(4, '0').toUpperCase();
      });
  // .replace(/[^ -~]/g, ch => {
  //     // Replace non-printable ASCII characters with Unicode escape sequences
  //     return '\\u' + ch.charCodeAt(0).toString(16).padStart(4,
  //     '0').toUpperCase();
  // });
}

// Read the JSON file
const filePath = path.join(__dirname, 'whatwg', 'urltestdata.json');
const fileData = fs.readFileSync(filePath, 'utf8');

// Parse the JSON data
const jsonData = JSON.parse(fileData);

// Get the parent directory path
const parentDir = path.join(__dirname, '..');

// Specify the file path in the parent directory
const outFile = path.join(parentDir, 'uri_whatwg_test.cpp');

const filename = path.basename(__filename);
let result =
    `// Automatically generated by ${filename} on ${new Date().toISOString()}
// Use ${filename} to generate this file, DO NOT EDIT MANUALLY.
//
// If you ever update "urltestdata.json" and regenerated this file,
// make sure to update the link in the assets/whatwg/README.md file as well.

#include "../webpp/uri/uri.hpp"

#include "./common/tests_common_pch.hpp"

using namespace webpp;


using Types =
  testing::Types<uri::parsing_uri_context_string<stl::string>,
                 uri::parsing_uri_context_string<stl::string_view>,
                 // uri::parsing_uri_context_string<stl::basic_string_view<char8_t>>,
                 uri::parsing_uri_context_u32,
                 uri::parsing_uri_context_segregated<>,
                 uri::parsing_uri_context_segregated_view<>,
                 uri::parsing_uri_context<stl::string_view, char const*>>;

template <class T>
struct URIWhatwgTest : testing::Test {
  private:
    stl::string url_text;

  public:
    template <typename SpecifiedTypeParam, typename StrT = stl::string_view>
    [[nodiscard]] constexpr SpecifiedTypeParam get_context(StrT str) {
        using ctx_type    = SpecifiedTypeParam;
        using string_type = stl::remove_cvref_t<StrT>;
        using str_iter    = typename string_type::const_iterator;
        using iterator    = typename ctx_type::iterator;
        if constexpr (stl::convertible_to<str_iter, iterator>) {
            return SpecifiedTypeParam{.beg = str.begin(), .pos = str.begin(), .end = str.end()};
        } else if constexpr (stl::convertible_to<stl::string::iterator, iterator>) {
            url_text = str;
            return SpecifiedTypeParam{.beg = url_text.begin(),
                                      .pos = url_text.begin(),
                                      .end = url_text.end()};
        } else {
            return SpecifiedTypeParam{.beg = str.data(), .pos = str.data(), .end = str.data() + str.size()};
        }
    }

    template <typename SpecifiedTypeParam>
    [[nodiscard]] constexpr SpecifiedTypeParam parse_from_string(stl::string_view const str) {
        auto ctx = get_context<SpecifiedTypeParam, stl::string_view>(str);
        uri::parse_uri(ctx);
        return ctx;
    }


    template <typename SpecifiedTypeParam>
    [[nodiscard]] constexpr SpecifiedTypeParam parse_from_string(stl::string_view const str, stl::string_view const base_str) {
        auto ctx = get_context<SpecifiedTypeParam, stl::string_view>(str);
        uri::parse_uri(ctx);

        using iterator = typename stl::string_view::const_iterator;
        using base_context_type = uri::parsing_uri_context<stl::uint32_t, iterator>;

        base_context_type origin_context{.beg = base_str.begin(), .pos = base_str.begin(), .end = base_str.end()};
        uri::parse_uri(origin_context);

        uri::parse_uri(str, origin_context.out);
        return ctx;
    }

};

TYPED_TEST_SUITE(URIWhatwgTest, Types);



`

let reason = "";
let index = 1;
let testNum = 1;

// Iterate over the tests
for (const test of Object.values(jsonData)) {

  // ignore invalid ones
  if (test === null) {
    continue;
  }

  if (typeof test !== "object") {
    index = 1;
    reason = test;
    continue;
  }
  const testName = `${convertToCamelCase(reason)}${index}`;

  result += `
// ${testNum} - ${reason} (${index})
TYPED_TEST(URIWhatwgTest, ${testName}) {
`
  if (test.base !== null) {
    result +=
        `    auto const ctx = this->template parse_from_string<TypeParam>("${
            escapeForCppString(
                test.input)}", "${escapeForCppString(test.base)}");`;
  }
  else {
    result +=
        `    auto const ctx = this->template parse_from_string<TypeParam>("${
            escapeForCppString(test.input)}");`;
  }

  if (test.failure !== undefined) {
    result += `
    EXPECT_FALSE(uri::is_valid(ctx.status)) << to_string(uri::get_value(ctx.status));`;
  } else {
    result += `
    EXPECT_TRUE(uri::is_valid(ctx.status)) << to_string(uri::get_value(ctx.status));`;
  }

  // scheme
  if (test.protocol !== undefined) {
    result += `
    EXPECT_EQ(ctx.out.get_scheme(), "${
        escapeForCppString(test.protocol.slice(0, -1))}");`;
  }

  // username
  if (test.username !== undefined) {
    result += `
    EXPECT_EQ(ctx.out.get_username(), "${escapeForCppString(test.username)}");`;
  }

  // password
  if (test.password !== undefined) {
    result += `
    EXPECT_EQ(ctx.out.get_password(), "${escapeForCppString(test.password)}");`;
  }

  // host
  if (test.host !== undefined) {
    //     result += `
    // EXPECT_EQ(ctx.out.get_host(), "${escapeForCppString(test.host)}");`;
  }

  // hostname
  if (test.hostname !== undefined) {
    result += `
    EXPECT_EQ(ctx.out.get_hostname(), "${escapeForCppString(test.hostname)}");`;
  }

  // port
  if (test.port !== undefined) {
    result += `
    EXPECT_EQ(ctx.out.get_port(), "${escapeForCppString(test.port)}");`;
  }

  // path
  if (test.pathname !== undefined) {
    result += `
    EXPECT_EQ(ctx.out.get_path(), "${escapeForCppString(test.pathname)}");`;
  }

  // queries
  if (test.search !== undefined) {
    result += `
    EXPECT_EQ(ctx.out.get_queries(), "${
        escapeForCppString(test.search.substring(1))}");`;
  }

  // fragment
  if (test.hash !== undefined) {
    result += `
    EXPECT_EQ(ctx.out.get_fragment(), "${
        escapeForCppString(test.hash.substring(1))}");`;
  }

  // href
  if (test.href !== undefined) {
    // result += `
    // EXPECT_EQ(ctx.out.get_href(), "${
    //    escapeForCppString(test.href)}");`;
  }

  // origin??
  if (test.origin !== undefined) {
    // result += `
    // EXPECT_EQ(ctx.out.get_href(), "${
    //    escapeForCppString(test.href)}");`;
  }

  // the end of the test:
  result += `
}

`;

  ++index;
  ++testNum;
}

const line =
    readline.createInterface({input : process.stdin, output : process.stdout});

line.question(`Write to ${outFile} [Y/n]: `, (answer) => {
  if (answer.toLowerCase() !== 'y' && answer.toLowerCase() !== 'yes' &&
      answer !== "") {
    console.log("Not written.");
    line.close();
    return;
  }

  // Write to file
  fs.writeFile(outFile, result, (err) => {
    if (err) {
      console.error('Error writing to file:', err);
    } else {
      console.log('File written successfully!');
    }
    line.close();
  });
});
